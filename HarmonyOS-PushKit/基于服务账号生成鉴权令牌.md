基于服务账号生成鉴权令牌
更新时间: 2026-01-14 17:55
概述
服务账号（Service Account）是一种可实现服务器与服务器之间接口鉴权的账号，在华为开发者联盟的API Console上创建服务账号，您可根据返回的公私钥在业务应用中生成鉴权令牌，调用支持此类鉴权的华为公开API。

服务账号令牌为JWT（JSON Web Token）格式字符串，JWT数据格式包括三个部分：

Header（头部）
Payload（负载）
Signature（签名）
这三个部分通过“.”进行连接，其中Signature为通过SHA256withRSA/PSS算法对Header与Payload拼接的字符串签名生成的字符串。

示例

eyJra*****JjNjBjMXXX.
eyJhd*****JodHRXXX.
BRNss*****7az5oU7-Zp5g9X2WJVXXX
更多JWT的相关知识请参见Introduction to JSON Web Tokens。

开发步骤
创建服务账号密钥文件。
您需要在华为开发者联盟的API Console上创建并下载推送服务API的服务账号密钥文件，凭证创建入口如下图所示，选择所在项目，创建“服务账号密钥“凭证。相关创建步骤请参见API服务操作指南-服务账号密钥。

点击放大

您申请后的服务账号密钥样例文件形式可参考（文件内容已经经过脱敏处理）：

{
    "project_id": "*****",
    "key_id": "*****",
    "private_key": "-----BEGIN PRIVATE KEY-----\nMIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQCKw6kJKtCh7qmMvp1u1dI27z2TKZrPOzHbQaXO/Eez0AWZ2EN+ouF496R3pfo7fQXC1XOT/YTbVC4DNZwWSMA54fu3/AOCY9Zzyi46OK*****==\n-----END PRIVATE KEY-----\n",
    "sub_account": "*****",
    "auth_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/authorize",
    "token_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/token",
    "auth_provider_cert_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/certs",
    "client_cert_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/x509?client_id="
}
请确认以上密钥文件中的project_id是否与您的应用所属项目一致。
您的应用所属项目ID查看方法：登录AppGallery Connect网站，选择“开发与服务”，在项目列表中选择对应的项目，左侧导航栏选择“项目设置”，在该页面获取。

点击放大

生成JWT Header数据。
根据服务账号密钥文件中的key_id（对应示例中的kid）字段拼接以下JSON体，对JSON体进行BASE64编码。

示例

{
  "kid": "*****",
  "typ": "JWT",
  "alg": "PS256"
}
字段名

描述

kid

服务账号密钥文件中key_id字段。

typ

数据类型，固定为：JWT。

alg

算法类型，固定为：PS256。

生成JWT Payload数据。
根据服务账号密钥文件中的sub_account（对应示例中的iss）字段拼接以下JSON体，对JSON体进行BASE64编码。

示例

{
  "aud": "https://oauth-login.cloud.huawei.com/oauth2/v3/token",
  "iss": "*****",
  "exp": 1581410664,
  "iat": 1581407064
}
字段名

描述

iss

服务账号密钥文件中sub_account字段，标识数据生成者。

aud

固定为：https://oauth-login.cloud.huawei.com/oauth2/v3/token。

iat

JWT签发UTC时间戳，为自UTC时间1970年1月1日00:00:00起的秒数（您的服务器时间需要校准为标准时间）。

exp

JWT到期UTC时间戳，比iat晚3600秒。

生成JWT Token。
将完成BASE64编码后的Header字符串与Payload字符串，通过“.”进行连接，您可在业务应用中，通过服务账号密钥文件中的private_key（华为不进行存储，请您妥善保管），使用SHA256withRSA/PSS算法对拼接的字符串签名。

至此，您已经完成服务账号鉴权令牌JWT Token的生成。

调用推送服务REST API
您的应用调用推送服务REST API时，需要把已获得的服务账号鉴权令牌放在Authorization头部来进行鉴权。请使用v3版本调用推送服务REST API。

示例

POST "https://push-api.cloud.huawei.com/v3/3158882***52863/messages:send"
Authorization: Bearer eyJr*****OiIx---****.eyJh*****iJodHR--***.QRod*****4Gp---****
push-type:0
说明
Authorization格式：Bearer后面拼接空格，再拼接获取的鉴权信息。

接口版本：请使用V3版本调用推送服务REST API。

场景化消息请求体中，接口URL版本为V3（https://push-api.cloud.huawei.com/v3/[projectId]/messages:send）时，仅支持给HarmonyOS Next/5.x及之后的系统版本推送通知；接口URL版本为V2（https://push-api.cloud.huawei.com/v2/[projectId]/messages:send）时，仅支持给HarmonyOS 3.x/4.x的系统版本推送通知。

示例代码
为了方便您生成服务账号鉴权令牌，我们提供了Java语言的示例代码，请按照说明替换参数运行。

如果您使用其他开发语言，请选择对应的JWT开源组件进行开发。

其中鉴权令牌生成步骤如下：

完成上述开发步骤中的步骤1创建服务账号密钥文件后，从华为开发者联盟的API Console上创建并下载推送服务API的服务账号密钥文件（.json文件），格式如下：


以上json文件复制至工程中，参考如下代码进行解析（以private.json为例）。
Java
Node.js
Go
Python
PHP
// 依赖：go get github.com/golang-jwt/jwt/v5

package main

import (
    "encoding/json"
    "encoding/pem"
    "errors"
    "fmt"
    "github.com/golang-jwt/jwt/v5"
    "log"
    "os"
    "strings"
    "time"
)

type ServiceAccountKey struct {
    KeyID      string `json:"key_id"`
    SubAccount string `json:"sub_account"`
    PrivateKey string `json:"private_key"`
}

func main() {
    // 替换为实际JSON文件路径，此处以本文件同级目录为例
    signedToken, err := generateJWTToken("private.json")
    if err != nil {
        log.Fatalf("Failed to generate JWT token: %v", err)
    }

    // signedToken为鉴权令牌，调用推送服务REST API时放在Authorization头部来进行鉴权。
    sendMessage(signedToken)
}

func sendMessage(token string) {
    // 自行实现业务流程
}

func generateJWTToken(keyFile string) (string, error) {
    saKey, err := loadServiceAccountKey(keyFile)
    if err != nil {
        return "", err
    }

    formattedPrivateKey, err := formatPrivateKey(saKey.PrivateKey)
    if err != nil {
        return "", err
    }

    privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(formattedPrivateKey))
    if err != nil {
        return "", fmt.Errorf("failed to parse private key: %w", err)
    }

    token, err := buildJWTToken(saKey.KeyID, saKey.SubAccount)
    if err != nil {
        return "", err
    }

    return token.SignedString(privateKey)
}

// buildJWTToken 构造 JWT token 对象
func buildJWTToken(keyID, subAccount string) (*jwt.Token, error) {
    now := time.Now().UTC()
    iat := now.Unix()
    exp := iat + 3600 // token 过期时间：一小时后

    claims := jwt.MapClaims{
        // 实际开发时请将公网地址存储在配置文件或数据库
        "aud": "https://oauth-login.cloud.huawei.com/oauth2/v3/token",
        "iss": subAccount,
        "exp": exp,
        "iat": iat,
    }

    token := jwt.NewWithClaims(jwt.SigningMethodPS256, claims)

    // 设置 header
    token.Header["kid"] = keyID
    token.Header["typ"] = "JWT"
    token.Header["alg"] = "PS256"

    return token, nil
}

// loadServiceAccountKey 从 JSON 文件加载服务账号密钥
func loadServiceAccountKey(filename string) (*ServiceAccountKey, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("failed to read key file: %w", err)
    }

    var saKey ServiceAccountKey
    if err := json.Unmarshal(data, &saKey); err != nil {
        return nil, fmt.Errorf("failed to parse key file: %w", err)
    }

    if saKey.KeyID == "" || saKey.SubAccount == "" || saKey.PrivateKey == "" {
        return nil, errors.New("invalid service account key file: missing required fields")
    }

    return &saKey, nil
}

// formatPrivateKey 格式化私钥字符串为 PEM 格式
func formatPrivateKey(privateKeyStr string) (string, error) {
    trimmed := strings.TrimSpace(privateKeyStr)

    // 如果已经是 PEM 格式，则直接返回
    if strings.HasPrefix(trimmed, "-----BEGIN PRIVATE KEY-----") &&
        strings.HasSuffix(trimmed, "-----END PRIVATE KEY-----") {
        return trimmed, nil
    }

    block, _ := pem.Decode([]byte(trimmed))
    if block == nil {
        return "", errors.New("failed to decode PEM block")
    }

    pemBytes := pem.EncodeToMemory(block)
    if pemBytes == nil {
        return "", errors.New("failed to encode private key to PEM format")
    }

    return string(pemBytes), nil
}